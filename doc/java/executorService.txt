

    Runnable rr = new Runnable() {
        @Override
        public void run() {
            // set thread to match???
            for (Runnable r : al) {
                r.run();
            } 
        }
    };
    getExecutorService().submit(rr);
    int x = queExecutorService.size();
    if (x > 19 && x % 10 == 0) {
        LOG.fine("queueSize="+x);
    }


...


    // thread pool
    private ThreadPoolExecutor executorService;
    private LinkedBlockingQueue<Runnable> queExecutorService;
    protected ExecutorService getExecutorService() {
        if (executorService != null) return executorService;

        ThreadFactory tf = new ThreadFactory() {
            AtomicInteger ai = new AtomicInteger();
            @Override
            public Thread newThread(Runnable r) {
                OARemoteThread t = new OARemoteThread(r, false); // needs to be this type of thread
                t.setName("Multiplexer.executorService."+ai.getAndIncrement());
                t.setDaemon(true);
                t.setPriority(Thread.NORM_PRIORITY);
                return t;
            }
        };
        
        queExecutorService = new LinkedBlockingQueue<Runnable>(Integer.MAX_VALUE);
        // min/max must be equal, since new threads are only created when queue is full
        executorService = new ThreadPoolExecutor(10, 10, 60L, TimeUnit.SECONDS, 
                queExecutorService, tf) 
        {
            @Override
            public Future<?> submit(Runnable task) {
                LOG.fine("running task in thread="+Thread.currentThread().getName());
                return super.submit(task);
            }
        };
        executorService.allowCoreThreadTimeOut(true);  // must have this
        
        return executorService;
    }
