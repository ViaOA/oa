

>> sample que 
    private volatile Thread threadMessageQueue;
    private AtomicInteger aiStart = new AtomicInteger();
    private LinkedBlockingQueue<?> queMessage = new LinkedBlockingQueue<?>();


    public void start() throws Exception {
        bIsStarted = true;
        aiStart.incrementAndGet();
        startQueueThread();
    }

    public void close() {
        if (!bIsStarted) return;
        bIsStarted = false;
        aiStart.incrementAndGet();
        queOnMessage.clear();
        threadMessageQueue = null;
    }

    
    <code>
        queMessage.offer(?);
    </code>

    protected void startQueueThread() {
        if (threadMessageQueue != null) return;

        log("creating single thread and queue to process LLAD messages");
        final int cntStart = aiStart.get();
        
        Runnable rr = new Runnable() {
            public void run() {
                long msLastException = 0;
                for (int i=0; ;i++) {
                    if (cntStart != aiStart.get()) break;
                    if (!bIsStarted) break;
                    try {
                        QueMessage qm = queOnMessage.poll(5, TimeUnit.SECONDS);
                        if (!bIsStarted) break;
                        <process...>
                    }
                    catch (Exception e) {
                        LOG.log(Level.WARNING, "Error processing queue", e);
                        long ms = System.currentTimeMillis();
                        if (msLastException > 0 && ((ms - msLastException) < 1000) ) {
                            try {
                                Thread.sleep(1000);
                            }
                            catch (InterruptedException e2) {
                            }
                        }
                        msLastException = ms;
                    }
                }
            }
        };
        threadMessageQueue = new Thread(rr, "Name.queue");
        threadMessageQueue.setDaemon(true);
        threadMessageQueue.start();
    }




Volatile
   http://www.ibm.com/developerworks/java/library/j-jtp06197/index.html
   http://blog.webscale.co.in/?p=19
   double-check locking
   

>> Shutdown hook
        // this will be started by Runtime when program is exiting - including when control 'C' is used
        if (threadShutDown == null) {
            threadShutDown = new Thread(new Runnable() {
                public void run() {
                    // System.out.println("OAClient.shutDownHook called");
                    if (oaClient != null && !oaClient.bIsServer) oaClient.close(false);
                }
            }, "OAClient.shutDown");
            threadShutDown.setDaemon(true);
            Runtime.getRuntime().addShutdownHook(threadShutDown);
        }


>> Thread



>> SwingWorker
    ** see swing/swingworker.txt


>> Future<V>
    // result from an executed service

    cancel(boolean mayInterruptIfRunning) 
    
    get()
    get(long timeout, TimeUnit unit) 
    
    isCancelled, isDone


>> Callable<V> 
    // interface with callable method
    call()
    

>> FutureTask<V>

    FutureTask<String> future =
       new FutureTask<String>(new Callable<String>() {
         public String call() {
           return searcher.search(target);
       }});
     executor.execute(future);
     
     <V> get()


>> ExecutorCompletionService<V>
    // submits x amount of callable objects to a threads
    
    // ex:  r = ecs.take().get();  -- take will get next executeThread callable object
    
    
>> Executors
    // factory
    // converts runnable to callable
    // thread factory
    // ExecutorService
    // privilegedCallable
    // single thread factory
    
    
>> ThreadPoolExecutor
    // create using Executors factory to create
    

>> StackTrace  

    public static String getAllStackTraces() {
        String result = "";
        String s = "DumpAllStackTraces "+(new OADateTime());
        result += s + "\n";

        Map<Thread,StackTraceElement[]> map = Thread.getAllStackTraces();
        Iterator it = map.entrySet().iterator();
        for (int i=1 ; it.hasNext(); i++) {
            Map.Entry me = (Map.Entry) it.next();
            Thread t = (Thread) me.getKey();
            s = i+") " + t.getName();
            result += s + "\n";
            
            StackTraceElement[] stes = (StackTraceElement[]) me.getValue();
            if (stes == null) continue;
            for (StackTraceElement ste : stes) {
                s = "  "+ste.getClassName()+" "+ste.getMethodName()+" "+ste.getLineNumber();
                result += s + "\n";
            }
        }
        return result;
    }
    
    
    
    