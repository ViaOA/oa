




* hashMap

        HashMap<Employee, ArrayList<EmployeeAward>> hm = new HashMap<>();
        for (Entry<Employee, ArrayList<EmployeeAward>> entry : hm.entrySet()) {
            Employee manager = entry.getKey();
            ArrayList<EmployeeAward> al = entry.getValue();
            ...
        }


        for (Value value : hmInfo.values()) {
            ..            
        }


        for (String s : hmInfo.keySet()) {
            ..
        }

* list

        for (Iterator<Tuple<Server, ServerStatus>> iter = al.iterator(); iter.hasNext();) {
            Tuple<Server, ServerStatus> t = iter.next();                        
            if (t.a.getServerStatus() != t.b) {
                iter.remove();  // dont use al.remove(t);
                continue;
            }
         }


* see concurrent.txt
        for (Map.Entry<Hub, OADateTime> entry : this.hmHub.entrySet()) { 
            OADateTime dt = entry.getValue();
            if (dt.after(dtCheck)) {
                hmHub.remove(entry.getKey());
            }
        }

* 
        Set<Map.Entry<OASelect, Void>> set = hmSelect.entrySet();
        for (Iterator it = set.iterator() ; it.hasNext(); ) {
            it.next();
            ..
            it.remove();
            
        }

>>  from OASelectManager

    private static ConcurrentHashMap<OASelect, Void> hmSelect = new ConcurrentHashMap<OASelect, Void>(23, .75f, 3);
    protected static void performCleanup() {
        LOG.fine("checking selects");
        long time = new Date().getTime();
        time -= (timeLimitInSeconds * 1000);

        int iTotal = hmSelect.size();
        Set<Map.Entry<OASelect, Void>> set = hmSelect.entrySet();
        
        for (Iterator<Map.Entry<OASelect, Void>> it = set.iterator() ; it.hasNext(); ) {
            Map.Entry<OASelect, Void> me = it.next();
            OASelect sel = me.getKey();
            iTotal++;
            if (sel.isCancelled()) {
                it.remove();
                continue;
            }
            
            if (!sel.hasBeenStarted()) continue;
            
            long t = sel.getLastReadTime();
            if (t == 0) continue;
            
            if (t < time) {
                sel.cancel();
                it.remove();
            }
        }
        LOG.fine("done, before="+iTotal+", after="+hmSelect.size());
    }
