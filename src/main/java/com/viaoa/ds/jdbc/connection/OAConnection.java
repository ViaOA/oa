/*
This software and documentation is the confidential and proprietary
information of ViaOA, Inc. ("Confidential Information").
You shall not disclose such Confidential Information and shall use
it only in accordance with the terms of the license agreement you
entered into with ViaOA, Inc.

ViaOA, Inc. MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THE
SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE, OR NON-INFRINGEMENT. ViaOA, Inc. SHALL NOT BE LIABLE FOR ANY DAMAGES
SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR DISTRIBUTING
THIS SOFTWARE OR ITS DERIVATIVES.

Copyright (c) 2001-2013 ViaOA, Inc.
All rights reserved.
*/
package com.viaoa.ds.jdbc.connection;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.sql.*;
import com.viaoa.util.*;

/**
    Used to <i>wrap</i> functionality around a java.sql.Connection to offer 
    Statement Pooling.  Mostly used internally by ConnectionPool.
*/
public class OAConnection {
    private static Logger LOG = Logger.getLogger(OAConnection.class.getName());
    
    protected Connection connection;
    protected Vector vecStatement = new Vector(5,5);
    protected Vector vecPreparedStatement = new Vector(5,5);
    protected boolean bAvailable;
    protected int statementCount;
    
    public OAConnection(Connection con) {   
        connection = con;
    }

    static int ppCntx;
    static long tsPPLastx = 0;
    
static int ppCnt;
static long tsPPLast = 0;
    public PreparedStatement getPreparedStatement(String sql, boolean bHasAutoGenerated) throws SQLException {
        synchronized (vecPreparedStatement) {
            ArrayList<PreparedStatement> al = hmPreparedStatements.get(sql);
            if (al != null) {
                for (PreparedStatement ps : al) {
                    if (!vecPreparedStatement.contains(ps)) {
                        vecPreparedStatement.addElement(ps);

                        ++ppCntx;
/*                        
                        if (ppCntx % 2500 == 0 || tsPPLastx == 0 || (System.currentTimeMillis() - tsPPLastx) > 10000) {
                            System.out.println((ppCntx)+" reusing OAConnection PreparedStatement: "+sql);        
                            tsPPLastx = System.currentTimeMillis();
                        }
*/                        
                        return ps;
                    }
                }
            }
        }

        PreparedStatement ps;
        if (bHasAutoGenerated) ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); 
        else ps = connection.prepareStatement(sql); 
        
//qqqqqqqqqqqqqqqq
        ++ppCnt;
/*        
        if (ppCnt % 250 == 0 || tsPPLast == 0 || (System.currentTimeMillis() - tsPPLast) > 5000) {
            System.out.println((ppCnt)+" NEW OAConnection.getPreparedStatement: "+sql);        
            tsPPLast = System.currentTimeMillis();
        }
*/        
        synchronized (vecPreparedStatement) {
            vecPreparedStatement.addElement(ps);
            ArrayList<PreparedStatement> al = hmPreparedStatements.get(sql);
            if (al == null) al = new ArrayList<PreparedStatement>();
            al.add(ps);
            hmPreparedStatements.put(sql, al);
            hmPreparedStatements2.put(ps, sql);
        }
        return ps;
    }

    private ConcurrentHashMap<String, ArrayList<PreparedStatement>> hmPreparedStatements = new ConcurrentHashMap<String, ArrayList<PreparedStatement>>();
    private ConcurrentHashMap<PreparedStatement, String> hmPreparedStatements2 = new ConcurrentHashMap<PreparedStatement, String>();

    public boolean releasePreparedStatement(PreparedStatement ps, boolean bCanBeReused) {
        boolean bFound = false;
        synchronized (vecPreparedStatement) {
            int x = vecPreparedStatement.size();
            for (int i=0; i < x; i++) {
                PreparedStatement ps2 = (PreparedStatement) vecPreparedStatement.elementAt(i);
                if (ps2 == ps) {
                    vecPreparedStatement.removeElementAt(i);
                    bFound = true;
                    break;
                }
            }
        }
        if (bFound && !bCanBeReused) {
            synchronized (vecPreparedStatement) {
                String sql = hmPreparedStatements2.get(ps);
                if (sql != null) {
                    hmPreparedStatements2.remove(ps);
                    ArrayList<PreparedStatement> al = hmPreparedStatements.get(sql);
                    if (al != null) {
                        al.remove(ps);
                        if (al.size() == 0) hmPreparedStatements.remove(sql);
                    }
                }
            }
        }
        return bFound;
    }


    static int stCnt;
    static long tsSTLast = 0;

    public Statement getStatement(String message) throws SQLException {
        Statement statement = null;
        //message = OAString.format(new OADateTime(),"MM/dd HH:mm:ss") + " " + message;
        statementCount++;

      //qqqqqqqqqqqqqqqq
        ++stCnt;
/*        
        if (stCnt % 500 == 0 || tsSTLast == 0 || (System.currentTimeMillis() - tsSTLast) > 5000) {
            System.out.println((stCnt)+" new OAConnection.getStatement: "+message);        
            tsSTLast = System.currentTimeMillis();
        }
*/        
        
        /* 20120628 turning off statement reuse
        synchronized (vecStatement) {
            int x = vecStatement.size();
            for (int i=0; i < x; i++) {
                Pool pool = (Pool) vecStatement.elementAt(i);
                if (!pool.used) {
                    pool.used = true;
                    pool.message = message;
                    return pool.statement;
                }
            }
        }
        */
        
        
        // 20120625 can use later, need to test
        // statement = connection.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
        statement = connection.createStatement();
        // statement.setPoolable(true); // 20120625 can use later, need to test
        Pool pool = new Pool(statement,true, message);
        synchronized (vecStatement) {
            vecStatement.addElement(pool);
        }
        
        if (vecStatement.size() > 10) {
            LOG.warning("StatementPool is too large, current="+vecStatement.size());
        }
        
        return statement;
    }

    /** returns true if found */
    public boolean releaseStatement(Statement statement) {
        synchronized (vecStatement) {
            int x = vecStatement.size();
            for (int i=0 ; i < x; i++) {
                Pool pool = (Pool) vecStatement.elementAt(i);
                if (pool.statement != statement) continue;
                pool.used = false;
                try {
                    if (!statement.isClosed()) {
                        statement.close();
                    }
                }
                catch (Exception e) {
                    LOG.log(Level.WARNING, "Exception releasing statement", e);
                }
                vecStatement.remove(i);
                return true;
            }
        }            
        return false;
    }

    public int getNumberOfUsedStatements() {
        int totalUsed = 0;
        synchronized (vecStatement) {
            int x = vecStatement.size();
            for (int i=0 ; i < x; i++) {
                Pool pool = (Pool) vecStatement.elementAt(i);
                if (pool.used) totalUsed++;
            }
        }            
        return totalUsed;
    }

    public void getInfo(Vector vec) {
        try {
            if (connection.isClosed()) vec.addElement("   Connection is closed");
        }
        catch (Exception e) {
        }
        synchronized (vecStatement) {
            int x = vecStatement.size();
            for (int i=0 ; i < x; i++) {
                Pool pool = (Pool) vecStatement.elementAt(i);
                if (pool.used) vec.addElement("  "+i+") "+pool.message); 
            }
        }            
    }
    
    public int getStatementUsedCount() {
        return statementCount;
    }
    
    /** internal class used by Connection to get a list of Statement objects
    */
    class Pool {
        Statement statement;
        boolean used;
        String message;
            
        public Pool(Statement s, boolean b, String message) {
            statement = s;
            used = b;
            this.message = message;
        }
    }
    
}
    
